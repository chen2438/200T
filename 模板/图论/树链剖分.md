### AcWing 2568. 树链剖分

#### 题目描述

![image-20220807125718853](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-08-07-045719.png)

![image-20220807125733510](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-08-07-045733.png)

#### 代码

区间修改, 区间查询

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

typedef long long LL;
const int N = 100010, M = N * 2;

int n, m;

namespace LSGT{
    int nw[N];
    //dfs序第i个点的权值,即线段树模拟的真实数组
    struct Tree{
        int l, r;
        LL add, sum;
    }tr[N * 4];
    void pushup(int u){
        tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
    }
    void pushdown(int u){
        auto &root = tr[u], &left = tr[u << 1], &right = tr[u << 1 | 1];
        if (root.add){
            left.add += root.add, left.sum += root.add * (left.r - left.l + 1);
            right.add += root.add, right.sum += root.add * (right.r - right.l + 1);
            root.add = 0;
        }
    }
    void build(int u, int l, int r){
        tr[u] = {l, r, 0, nw[r]};
        if (l == r) return;
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
    void update(int u, int l, int r, int k){
        if (l <= tr[u].l && r >= tr[u].r){
            tr[u].add += k;
            tr[u].sum += k * (tr[u].r - tr[u].l + 1);
            return;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) update(u << 1, l, r, k);
        if (r > mid) update(u << 1 | 1, l, r, k);
        pushup(u);
    }
    LL query(int u, int l, int r){
        if (l <= tr[u].l && r >= tr[u].r) return tr[u].sum;
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        LL res = 0;
        if (l <= mid) res += query(u << 1, l, r);
        if (r > mid) res += query(u << 1 | 1, l, r);
        return res;
    }
}using namespace LSGT;

namespace TRCD{
    struct Edge{
    	int to,nxt;
    }e[M];
    int adt,head[N],w[N];
    void add(int u,int v){
    	e[++adt]={v,head[u]};
    	head[u]=adt;
    }
    int id[N], cnt;
    //dfs序编号
    int dep[N], sz[N], top[N], fa[N], son[N];
    //深度,子树大小,所在重链的顶点,父节点,重儿子
    void dfs1(int u, int father, int depth){
        dep[u] = depth, fa[u] = father, sz[u] = 1;
        for (int i = head[u]; i; i = e[i].nxt){
            int j = e[i].to;
            if (j == fa[u]) continue;
            dfs1(j, u, depth + 1);
            sz[u] += sz[j];
            if (sz[son[u]] < sz[j]) son[u] = j;
        }
    }
    void dfs2(int u, int t){
        id[u] = ++ cnt, nw[cnt] = w[u], top[u] = t;
        if (!son[u]) return;
        dfs2(son[u], t);
        for (int i = head[u]; i; i = e[i].nxt){
            int j = e[i].to;
            if (j == fa[u] || j == son[u]) continue;
            dfs2(j, j);
        }
    }
    void update_path(int u, int v, int k){
        while (top[u] != top[v]){
            if (dep[top[u]] < dep[top[v]]) swap(u, v);
            update(1, id[top[u]], id[u], k);
            u = fa[top[u]];
        }
        if (dep[u] < dep[v]) swap(u, v);
        update(1, id[v], id[u], k);
    }
    LL query_path(int u, int v){
        LL res = 0;
        while (top[u] != top[v]){
            if (dep[top[u]] < dep[top[v]]) swap(u, v);
            res += query(1, id[top[u]], id[u]);
            u = fa[top[u]];
        }
        if (dep[u] < dep[v]) swap(u, v);
        res += query(1, id[v], id[u]);
        return res;
    }
    void update_tree(int u, int k){
        update(1, id[u], id[u] + sz[u] - 1, k);
    }
    LL query_tree(int u){
        return query(1, id[u], id[u] + sz[u] - 1);
    }
}using namespace TRCD;

void solve(){
    cin>>n;
    FOR(i,1,n) cin>>w[i];
    FOR(i,1,n-1){
        int a, b; cin>>a>>b;
        add(a, b), add(b, a);
    }
    dfs1(1, -1, 1);
    dfs2(1, 1);
    build(1, 1, n);
    cin>>m;
    while (m -- ){
        int t, u, v, k; cin>>t>>u;
        if (t == 1){
            cin>>v>>k;
            update_path(u, v, k);
        }
        else if (t == 2){
            cin>>k;
            update_tree(u, k);
        }
        else if (t == 3){
            cin>>v;
            cout<<query_path(u, v)<<endl;
        }
        else cout<<query_tree(u)<<endl;
    }
}

int main(){
    cin.tie(0)->sync_with_stdio(0);
    int T=1; //cin>>T;
    while(T--) solve();
    return 0;
}
```

