## 前缀和

### C. Tokitsukaze and Strange Inequality

#### 题意

![image-20220811163946293](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-08-11-083946.png)

#### 思路

![image-20220811164015119](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-08-11-084015.png)

![image-20220811164026622](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-08-11-084026.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
#define mem(a) memset((a),0,sizeof(a))
#define endl '\n'
#define int long long
using namespace std;

const int N = 5e3+7;
int a[N],pre[N][N];

void solve(){
    int n; cin>>n;
    FOR(i,1,n) cin>>a[i];
    FOR(i,0,n) FOR(j,0,n) pre[i][j]=0;
    FOR(i,1,n){
        FOR(j,1,n){
            pre[i][j]+=pre[i-1][j];
            if(a[i]<=j) pre[i][j]++;
        }
    }
    int ans=0;
    FOR(b,2,n-2){
        FOR(c,b+1,n-1){
            ans+=pre[b-1][a[c]-1]*(pre[n][a[b]]-pre[c][a[b]]);
        }
    }
    cout<<ans<<endl;
}

signed main(){
    cin.tie(0)->sync_with_stdio(0);
    int T=1; cin>>T;
    while(T--) solve();
    return 0;
}
```



## 差分

### 差分数组

原数组 a, 构造数组 b.

使得 a[i] = b[1] + b[2] + b[3] + ... + b[i].

a 是 b 的前缀和, b 是 a 的差分.

差分可以看成前缀和的逆运算.

### 构造

定义法:

```cpp
b[1]=a[1]
b[2]=a[2]-a[1]
b[3]=a[3]-a[2]
...
b[n-1]=a[n-1]-a[n-2]
b[n]=a[n]-a[n-1]
->
a[n]=b[1]+ ... +b[n]
```

定义法等价于对 b[i, i] += a[i]:

```cpp
void insert(int l, int r, int c){
    b[l] += c;
    b[r + 1] -= c;
}
insert(i, i, a[i]);
```

### 区间修改

$a[l-> r] += c <=> b[l] += c, b[r+1] -= c$

### 性质

$a[1->n]+=c <=> b[1]+=c, b[n+1]-=c <=> b[1]+=c$

$a[n]+=c <=> b[n]+=c, b[n+1]-=c <=> b[n]+=c$

$b[n+1]$ 对 a 数组没有影响



让 a[] 相同, 等价于 b[1] = sum(a), b[2 -> n] = 0.

让 a[] 全为 0, 等价于 b[1 -> n] = 0.

### AcWing 797. 差分

https://www.acwing.com/problem/content/799/

![image-20230227173022429](https://media.opennet.top/i/2023/02/27/63fc782f6b90a.png)

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;

const int N = 100010;

int n, m;
int a[N], b[N];

void insert(int l, int r, int c){
    b[l] += c;
    b[r + 1] -= c;
}

int main(){
    cin.tie(0)->sync_with_stdio(0);
    cin>>n>>m;
    FOR(i,1,n){
        cin>>a[i];
        insert(i, i, a[i]);
    }
    while (m -- ){
        int l, r, c;
        cin>>l>>r>>c;
        insert(l, r, c);
    }
    FOR(i,1,n){
        a[i] = b[i] += b[i - 1];
        cout<<a[i]<<' ';
    }
    return 0;
}
```

### AcWing 100. 增减序列

https://www.acwing.com/problem/content/102/

![image-20230227173041357](https://media.opennet.top/i/2023/02/27/63fc78426fe9a.png)

#### 思路

让 $a[]$ 相同, 等价于 $b[1] = a[1] = C, b[2, n] = 0$.

所以我们要找到最少的操作使 $b[2, n] = 0$.

由于 $a[l,r] += 1 <=> b[l] += 1, b[r+1] -= 1$

所以我们可以找到一正一负的 b[i], b[j] ($2 <= i, j <= n$), 在 1 次操作让它们趋近于 0.

当 b[2, n] 没有正数或负数时, 可以让它们与 b[1] 或 b[n+1] 相互作用. 这不影响我们的目标: 使 b[2, n] = 0.

所以最小操作次数是 $min(pos, neg) + abs(pos - neg) = max(pos, neg)$

下面考虑最终结果有多少种.

由于 b[1] = a[1], b[n + 1] 对 a 没有影响, 而我们在消去剩余的正数或负数时用到了 b[1] 和 b[n + 1]. 

消去剩余的正数或负数总共需要 abs(pos - neg) 次操作, 我们可以使用最少 0 次 b[1], 最多 abs(pos - neg) 次 b[1] (其余的操作交给 b[n + 1]). 不同的 b[1] 共有 abs(pos - neg) + 1 种.

不同的 b[1] 的数量即代表不同的 a 的数量, 因此最终得到 $abs(pos - neg) + 1$ 种结果.

#### 代码

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;

#define ll long long
const int N  = 1e5+10;

ll a[N],b[N],pos,neg;

int main(){
    int n;
    cin >> n;
    FOR(i,1,n){
        cin >> a[i];
        b[i] = a[i] - a[i-1];
    }
    FOR(i,2,n){
        if(b[i] > 0) pos += b[i];
        else neg -= b[i];
    }
    cout<<max(pos, neg)<<endl;
    cout<<abs(pos-neg) + 1;
    return 0;
}
```



### C. Helping the Nature

https://codeforces.com/contest/1700/problem/C

#### 标签

差分, 贪心

#### 题意

给定数组 a, 有 3 种操作.

1. 选择 i, 使 a[1 -> i] -= 1.
2. 选择 i, 使 a[i -> n] -= 1.

3. 使所有数 += 1

求使所有数变为 0 的最小操作数.

#### 思路

令 b 为 a 的差分数组.

操作等价于:

1. b[1] -= 1, b[i + 1] += 1.
2. b[i] -= 1.
3. b[1] += 1.

让 a[] 相同, 等价于 b[1] = a[1], b[2 -> n] = 0.

让 a[] 全为 0, 等价于 b[1 -> n] = 0.

发现, 能对 b[2, n] 操作的只有操作 1 和操作 2, 分别对应负数变 0 和正数变 0.

这样, 我们先利用操作 1、2 把 b[2, n] 全部处理为 0, 再单独处理 b[1] 即可.

#### 代码

![image-20220706133407749](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-07-06-053517.png)

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;

#define int long long
const int N = 2e5+7;
int a[N],b[N];

signed main(){
	//cin.tie(0)->sync_with_stdio(0);
	int T;cin>>T;
	while(T--){
		int n;cin>>n;
		FOR(i,1,n) cin>>a[i];
		FOR(i,1,n) b[i]=a[i]-a[i-1];
		int ans=0;
		FOR(i,2,n){
			if(b[i]>0){ans+=b[i];}
			if(b[i]<0){ans+=-b[i];b[1]-=-b[i];}
		}
		ans+=abs(b[1]);
		cout<<ans<<endl;
	}
	return 0;
}
```

### AcWing 798. 差分矩阵

#### 题目描述

![image-20230227173106197](https://media.opennet.top/i/2023/02/27/63fc785b870d9.png)

![image-20230227173115123](https://media.opennet.top/i/2023/02/27/63fc7863de25f.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
#define endl '\n'
using namespace std;

const int N = 1010;

int n, m, q;
int a[N][N], b[N][N];

void update(int x1, int y1, int x2, int y2, int c){
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}

void get_origin(){
    FOR(i,0,n) FOR(j,0,m) a[i][j]=0;
    FOR(i,0,n) FOR(j,0,m){
        a[i][j]=b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
    }
}

int main(){
    cin.tie(0)->sync_with_stdio(0);
    cin>>n>>m>>q;
    FOR(i,1,n)
        FOR(j,1,m){
            cin>>a[i][j];
            update(i,j,i,j,a[i][j]);
        }
    while (q -- ){
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        update(x1, y1, x2, y2, c);
    }
    get_origin();
    FOR(i,1,n){
        FOR(j,1,m) cout<<a[i][j]<<" ";
        cout<<endl;
    }
    return 0;
}
```

### Gaming

https://ac.nowcoder.com/acm/contest/38457

#### 题目描述

![image-20220812215330817](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208122153864.png)

![image-20220812215339076](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208122153120.png)

待补图

#### 思路

把所有区间加到 [1, m] 上，看哪个区间上的积分最小，把覆盖这个区间的所有段减掉。

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
#define endl '\n'
#define int long long
using namespace std;

const int N = 1e6+7;

int n, m;
int b[N];

void insert(int l, int r, int c){
    b[l] += c;
    b[r + 1] -= c;
}

signed main(){
    cin.tie(0)->sync_with_stdio(0);
    cin >> n >> m;
    int sum=0;
    for (int i = 0; i < n; i ++ ){
        int l,r,c; cin>>l>>r>>c;
        sum+=c;
        insert(l,r,c);
    }
    int mi=1e18;
    for(int i=1;i<=m;i++){
        b[i]+=b[i-1];
        mi=min(mi,b[i]);
    }
    cout<<sum-mi<<endl;
    return 0;
}
```

