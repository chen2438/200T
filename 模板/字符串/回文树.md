### Magic Spells

https://ac.nowcoder.com/acm/contest/33194/G

#### 题意



![image-20220815212234188](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208152122237.png)

#### 思路

![image-20220815212312330](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208152123371.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
#define endl '\n'
using namespace std;

const int N = 3e5+7;

namespace PAM{
    string s;
    int len[N],fail[N],tr[N][26],cnt[N],idx=1,last=0;
    /*
    len[u]:节点u代表的回文串的长度
    fail[u]:节点u代表的回文串的最大回文后缀(不含自己)的节点位置
    tr[u][c]:trie树,节点u,儿子c
    cnt[]:
    idx:fail指针的下标, 本质不同的回文串个数=idx-1
    last:s[:i - 1]后缀的最大回文串节点
    */
    int get_fail(int u,int i){
    	while(i-len[u]-1<0 or s[i]!=s[i-len[u]-1]) u=fail[u];
    	//检查s[i-len[u]-1]是否等于s[i]
        //如果等于,则得到了以s[i]结尾的最长回文串
        //如果不等于,则令u=link[u]直到满足
    	return u;
    }
    void build(int k){
    	len[0]=0,len[1]=-1;
    	fail[0]=1,fail[1]=1;
    	int lens=s.size();
    	FOR(i,0,lens-1){
    		int u=get_fail(last,i);
    		//利用fail的定义找出s[i]结尾的最长回文串
    		int c=s[i]-'a';
    		if(!tr[u][c]){
    		//如果tr[u][c]存在,说明已经处理过了
    		//如果不存在，则往trie树中加入一个新节点tr[u][c]=idx。
    			fail[++idx]=tr[get_fail(fail[u],i)][c];
    			tr[u][c]=idx;
    			len[idx]=len[u]+2;
    		}
    		last=tr[u][c];
    		if(cnt[last]==k-1){
            //当且仅当前面(k-1)个字符串都出现了节点last所代表的回文串,计数
    		    cnt[last]++;
            }
    	}
    }
}using namespace PAM;

void solve(){
    int k; cin>>k; 
    FOR(i,1,k){
        cin>>s;
        build(i);
    }
    int ans=0;
	FOR(i,1,idx) if(cnt[i]==k) ans++;
    cout<<ans<<endl;
}

signed main(){
    cin.tie(0)->sync_with_stdio(0);
    int T=1; //cin>>T;
    while(T--) solve();
    return 0;
}
```

