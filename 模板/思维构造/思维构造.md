### AcWing 4489. 最长子序列

![image-20220809100202863](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208091002913.png)

```cpp
//贪心, 双指针

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 200010;

int n;
int w[N];

int main(){
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &w[i]);
    int res = 0;
    for (int i = 0; i < n; i ++ ){
        int j = i + 1;
        while (j < n && w[j] <= w[j - 1] * 2) j ++ ;
        res = max(res, j - i);
        i = j - 1;
    }
    printf("%d\n", res);
    return 0;
}
```

### AcWing 4492. 减法操作

![image-20220809100300582](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208091003610.png)

```cpp
//偶数的最小质因子是2,奇数减掉奇数的最小质因子是偶数

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

int main(){
    LL n;
    cin >> n;
    LL res = 0;
    if (n % 2){
        for (int i = 2; i <= n / i; i ++ )
            if (n % i == 0){
                n -= i;
                res ++ ;
                break;
            }
        if (n % 2) res ++, n = 0;
    }
    res += n / 2;
    cout << res << endl;
    return 0;
}
```

### AcWing 4505. 最大子集

![image-20220809100414910](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208091004941.png)

```cpp
//手写哈希表; 子集长度最多为3

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 200010, M = 1999997, INF = 0x3f3f3f3f;

int n;
int q[N], ha[M];

int find(int x){
    int t = (x % M + M) % M;
    while (ha[t] != INF && ha[t] != x)
        if ( ++ t == M) t = 0;
    return t;
}

int main(){
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);
    sort(q, q + n);
    memset(ha, 0x3f, sizeof ha);
    int res[3], s[3];
    int rt = 0, st = 0;
    for (int i = 0; i < n; i ++ ){
        for (int j = 0; j <= 30; j ++ ){
            int d = 1 << j;
            s[0] = q[i], st = 1;
            for (int k = 1; k <= 2; k ++ ){
                int x = q[i] - d * k;
                if (ha[find(x)] == INF) break;
                s[st ++ ] = x;
            }
            if (rt < st){
                rt = st;
                memcpy(res, s, sizeof s);
                if (rt == 3) break;
            }
        }
        if (rt == 3) break;
        ha[find(q[i])] = q[i];
    }
    printf("%d\n", rt);
    for (int i = 0; i < rt; i ++ )
        printf("%d ", res[i]);
    return 0;
}
```

### AcWing 4504. 字符串消除

![image-20220809100448656](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208091004690.png)

```cpp
//可以证明，任意删除，能删就删，可以到相同的最终状态
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int main(){
    string str, stk;
    cin >> str;
    int res = 0;
    for (auto c: str)
        if (stk.back() == c){
            stk.pop_back();
            res ++ ;
        }
        else stk += c;
    if (res % 2) puts("Yes");
    else puts("No");
    return 0;
}
```

### Constructive Problems Never Die

https://ac.nowcoder.com/acm/contest/33192/C

![image-20220809100802047](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208091008088.png)

```cpp
void slove() {
    cin >> n;
    for (int i = 1; i <= n; i++)g[i].clear(), ans[i] = 0, vis[i] = 0;
    for (int i = 1; i <= n; i++)cin >> a[i], g[a[i]].push_back(i);
    vector<pair<int, int>>v;
    for (int i = 1; i <= n; i++) {
        if (g[i].size()) {
            v.push_back({ i,*g[i].begin() });
        }
    }
    if (v.size() == 1) {
        cout << "NO" << endl;
        return;
    }
    for (int i = 1; i < v.size(); i++) {
        ans[v[i].second] = v[i - 1].first;
        vis[v[i - 1].first] = 1;
    }
    ans[v.begin()->second] = v.back().first;
    vis[v.back().first] = 1;
    cout << "YES" << endl;
    int id = 1;
    for (int i = 1; i <= n; i++) {
        if (ans[i] == 0) {
            while (vis[id] == 1)id++;
            ans[i] = id;
            vis[id] = 1;
        }
    }
    for (int i = 1; i <= n; i++)cout << ans[i] << " ";
    cout << endl;
}
```

### Candies

https://ac.nowcoder.com/acm/contest/33192/F

![image-20220809100929154](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208091009191.png)

```cpp
//先拿一个栈进行从左往右的删除，再用双指针从两头扫，模拟环的删除

#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
#define mem(a) memset((a),0,sizeof(a))
#define endl '\n'
// #define int long long
using namespace std;

const int N = 2e5+7;

void solve(){
    int n,x;
    vector<int> stk;
    cin>>n>>x;
    int ans=0;
    FOR(i,1,n){
        int a; cin>>a;
        if(stk.empty()){stk.push_back(a);continue;}
        int t=stk.back();
        if(t==a or t+a==x){
            stk.pop_back();
            ans++;
        }
        else stk.push_back(a);
    }
    int l=0,r=stk.size()-1;
    while(l<r){
        if(stk[l]==stk[r] or stk[l]+stk[r]==x){
            l++,r--;
            ans++;
        }
        else break;
    }
    cout<<ans<<endl;
}

signed main(){
    cin.tie(0)->sync_with_stdio(0);
    int T=1; //cin>>T;
    while(T--) solve();
    return 0;
}
```

### D. The Enchanted Forest

https://codeforces.com/contest/1688/problem/D

**题意**

![image-20220810223850139](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208102238182.png)

**思路**

![image-20220810223929091](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208102239148.png)

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
#define mem(a) memset((a),0,sizeof(a))
#define endl '\n'
#define int long long
using namespace std;

const int N = 2e5+7, M=N*2;
int a[N],sum[N];

int get_sum(int l,int r){
    return sum[r]-sum[l-1];
}

int cal(int st,int ed){
    return (st+ed)*(ed-st+1)/2;
}

void solve(){
    int n,k; cin>>n>>k;
    FOR(i,1,n) cin>>a[i];
    FOR(i,0,n) sum[i]=0;
    FOR(i,1,n) sum[i]=sum[i-1]+a[i];
    int ans=0;
    if(k>n){
        ans=get_sum(1,n);
        ans+=(k-1)*n - n*(n-1)/2;
    }
    else{
        FOR(i,1,n-k+1)
            ans=max(ans,get_sum(i,i+k-1));
        ans+=cal(1,k-1);
    }
    cout<<ans<<endl;
}

signed main(){
    cin.tie(0)->sync_with_stdio(0);
    int T=1; cin>>T;
    while(T--) solve();
    return 0;
}
```

