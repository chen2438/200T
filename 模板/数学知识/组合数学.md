

## 排列

$A_n^m = A(n, m) =n(n-1)(n-2) \cdots  (n-m+1) = \frac{n!}{(n-m)!}$ 

## 组合

$C_n^m = C(n, m) = \frac{A_n^m}{m!} = \frac{n!}{m!(n-m)!} = C(n, n-m)$

需要用到费马小定理

**对于带模数的多组运算，可以考虑初始化阶乘数组，而不是直接求组合数**

```cpp
ll C(ll n,ll m,ll p){
    if(n<m) return 0;
    if(m>n-m) m=n-m;
    ll a=1,b=1;
    FOR(i,0,m-1){
        a=(a*(n-i))%p;
        b=(b*(i+1))%p;
    }
    return a*qpow(b,p-2,p)%p;
}
```

```cpp
const int N = 1e5+7;
const int p = 1e9+7;

ll fact[N];

void InitFact(){
	fact[0]=1;
	FOR(i,1,N){
		fact[i]=fact[i-1]*i%p;
	}
}

ll qpow(ll a,ll b,ll p){
    ll ans=1,base=a;
    while(b){
        if(b&1) ans*=base,ans%=p;
        base*=base,base%=p;
        b>>=1;
    }
    return ans;
}

ll A(ll n,ll m,ll p){
    return fact[n]*qpow(fact[n-m],p-2,p);
}

ll C(ll n,ll m,ll p){
    return fact[n]*qpow(fact[m],p-2,p)%p*qpow(fact[n-m],p-2,p)%p;
}
```

### AcWing 885. 求组合数 I

#### 数据范围

1e5 组查询, a,b \in 2e3

#### 代码

复杂度 $O(n^2)$

递推 预处理 组合数, 直接输出.

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;

const int N = 2010, mod = 1e9 + 7;

int c[N][N];

void init(){
    FOR(i,0,N-1)
        FOR(j,0,i)
            if (!j) c[i][j] = 1;
            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
}

int main(){
    int n; cin>>n;
    init();
    while (n -- ){
        int a, b; cin>>a>>b;
        cout<<c[a][b]<<'\n';
    }
    return 0;
}
```

### AcWing 886. 求组合数 II

#### 数据范围

1e4 组查询, a,b \in 1e5

#### 代码

复杂度 $O(n\log n)$

预处理组合数、逆元

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;

typedef long long LL;

const int N = 100010, mod = 1e9 + 7;

int fact[N], infact[N];

int qmi(int a, int k, int p){
    int res = 1;
    while (k){
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int main(){
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i ++ ){
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    }
    int n; cin>>n;
    while (n -- ){
        int a, b; cin>>a>>b;
        printf("%d\n", (LL)fact[a] * infact[b] % mod * infact[a - b] % mod);
    }
    return 0;
}
```

### AcWing 887. 求组合数 III

#### 数据范围

20 组查询, a,b \in 1e18, p \in 1e5

##### 代码

复杂度 $O(p \log n * \log p)$

卢卡斯定理 `C(n,m)%p = C(n/p,m/p) * C(n%p,m%p)%p`

```CPP
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

int qmi(int a, int k, int p){
    int res = 1;
    while (k){
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}


int C(int a, int b, int p){
    if (b > a) return 0;
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- ){
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2, p) % p;
    }
    return res;
}

int lucas(LL a, LL b, int p){
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}

int main(){
    int n; cin >> n;
    while (n -- ){
        LL a, b;
        int p;
        cin >> a >> b >> p;
        cout << lucas(a, b, p) << endl;
    }
    return 0;
}
```

