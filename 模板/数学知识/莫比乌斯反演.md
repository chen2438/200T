### 莫比乌斯函数

### 定义

$\mu$ 为莫比乌斯函数，定义为

$$
\mu(n)=
\begin{cases}
1&n=1\\
0&n\text{ 含有平方因子}\\
(-1)^k&k\text{ 为 }n\text{ 的本质不同质因子个数}\\
\end{cases}
$$

令 $n=\prod_{i=1}^kp_i^{c_i}$，其中 $p_i$ 为质因子，$c_i\ge 1$。

当 $n\not= 1$ 时：
1. 若存在 $i\in [1,k]$，使 $c_i > 1$，$\mu(n)=0$
2. 若对任意 $i\in[1,k]$，$c_i=1$ 恒成立，$\mu(n)=(-1)^k$



### 性质

莫比乌斯函数不仅是积性函数，还有如下性质：

$$
\sum_{d\mid n}\mu(d)=
\begin{cases}
1&n=1\\
0&n\neq 1\\
\end{cases}
$$

即 $\sum_{d\mid n}\mu(d)=\varepsilon(n)$，$\mu * 1 =\varepsilon$

$\sum_{d\mid n}$ 表示 $n$ 的所有约数。

### 线性筛莫比乌斯函数

```cpp
namespace MBUS{
    int primes[N], cnt, mu[N], musum[N];
    bool st[N];
    void mobius(){
        mu[1] = 1;
        FOR(i,2,N-1){
            if (!st[i]) primes[cnt ++ ] = i, mu[i] = -1;
            for (int j = 0; primes[j] * i < N; j ++ ){
                st[primes[j] * i] = true;
                if (i % primes[j] == 0) break;
                mu[primes[j] * i] = -mu[i];
            }
        }
        FOR(i,1,N-1) musum[i]=musum[i-1]+mu[i];
    }
    int sum(int l,int r) {return musum[r]-musum[l-1];}
}
```



### 莫比乌斯变换

形式一：如果有 $f(n)=\sum_{d\mid n}g(d)$，那么有 $g(n)=\sum_{d\mid n}\mu(d)f(\frac{n}{d})$。

这种形式下，数论函数 $f(n)$ 称为数论函数 $g(n)$ 的莫比乌斯变换，数论函数 $g(n)$ 称为数论函数 $f(n)$ 的莫比乌斯逆变换（反演）。

**形式二**：如果有 $F(n)=\sum_{n|d}f(d)$，那么有 $f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)$。

令 $d' = \frac{d}{n}$, 则 $f(n)=\sum_{d'}\mu(d')F(d),d'\in Z^+$



### AcWing 2702. problem b

https://www.acwing.com/problem/content/2704/

#### 题目描述

![image-20230227223056613](https://media.opennet.top/i/2023/02/27/63fcbea20f3d2.png)

#### 代码

<img src="http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-07-31-015249.png" alt="image-20220731095248353" style="zoom: 33%;" />

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

typedef long long LL;

const int N = 50010;

namespace MBUS{
    int primes[N], cnt, mu[N], musum[N];
    bool st[N];
    void mobius(){
        mu[1] = 1;
        FOR(i,2,N-1){
            if (!st[i]) primes[cnt ++ ] = i, mu[i] = -1;
            for (int j = 0; primes[j] * i < N; j ++ ){
                st[primes[j] * i] = true;
                if (i % primes[j] == 0) break;
                mu[primes[j] * i] = -mu[i];
            }
        }
        FOR(i,1,N-1) musum[i]=musum[i-1]+mu[i];
    }
    int sum(int l,int r) {return musum[r]-musum[l-1];}
}
int g(int k, int x){//数论分块
    return k / (k / x);
}

LL f(int a, int b, int k){
    a = a / k, b = b / k;
    LL res = 0;
    int n = min(a, b);
    for (int l = 1, r; l <= n; l = r + 1){
        r=min({n,g(a,l),g(b,l)});
        res += (LL)(MBUS::sum(l,r)) * (a / l) * (b / l);
    }
    return res;
}

int main(){
    MBUS::mobius();
    int T; scanf("%d", &T);
    while (T -- ){
        int a, b, c, d, k; scanf("%d%d%d%d%d", &a, &b, &c, &d, &k);
        printf("%lld\n",f(b,d,k)-f(a-1,d,k)-f(b,c-1,k)+f(a-1,c-1,k));
    }
    return 0;
}
```

### AcWing 1358. 约数个数和

#### 题目描述

![image-20220731104437134](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-07-31-024437.png)

#### 代码

引理: $d(i*j)=\sum_{x|i} \sum_{y|i}[gcd(x,y)=1]$

