### AcWing 839. 模拟堆

https://www.acwing.com/problem/content/841/

#### 题目描述

![image-20230227222638501](https://media.opennet.top/i/2023/02/27/63fcbd9fbee37.png)

![image-20230227222644994](https://media.opennet.top/i/2023/02/27/63fcbda5def06.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

const int N = 100010;

namespace HEAP{
    struct HP{
        int h[N], ph[N], hp[N], cnt, push_cnt;
        HP(){
            memset(h,0,sizeof h);
            memset(ph,0,sizeof ph);
            memset(hp,0,sizeof hp);
            cnt=push_cnt=0;
        }
        void heap_swap(int a, int b){
            swap(ph[hp[a]],ph[hp[b]]);
            swap(hp[a], hp[b]);
            swap(h[a], h[b]);
        }
        void down(int u){
            int t = u;
            if (u * 2 <= cnt && h[u * 2] < h[t]) t = u * 2;
            if (u * 2 + 1 <= cnt && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
            if (u != t){
                heap_swap(u, t);
                down(t);
            }
        }
        void up(int u){
            while (u / 2 && h[u] < h[u / 2]){
                heap_swap(u, u / 2);
                u >>= 1;
            }
        }
        void build(int n){//O(n)构造整个堆
            cnt=n;
            for (int i = n / 2; i; i -- ) down(i);
        }
        void push(int x){
            cnt ++ ;
            push_cnt ++ ;
            ph[push_cnt] = cnt, hp[cnt] = push_cnt;
            h[cnt] = x;
            up(cnt);
        }
        int top(){
            return h[1];
        }
        void pop(){
            heap_swap(1, cnt);
            cnt -- ;
            down(1);
        }
        void erase_k_push(int k){
            k = ph[k];
            heap_swap(k, cnt);
            cnt -- ;
            up(k);
            down(k);
        }
        void update_k_push(int k,int x){
            k = ph[k];
            h[k] = x;
            up(k);
            down(k);
        }
        int size(){
            return cnt;
        }
    };
}using namespace HEAP;

int main(){
    int n; cin>>n;
    HP heap;
    while (n -- ){
        string op; cin>>op;
        int k, x;
        if(op=="I"){
            cin>>x;
            heap.push(x);
        }
        if(op=="PM") cout<<heap.top()<<endl;
        if(op=="DM") heap.pop();
        if(op=="D"){
            cin>>k;
            heap.erase_k_push(k);
        }
        if(op=="C"){
            cin>>k>>x;
            heap.update_k_push(k,x);
        }
    }
    return 0;
}
```

### AcWing 838. 堆排序

https://www.acwing.com/problem/content/840/

#### 题目描述

![image-20230227222702572](https://media.opennet.top/i/2023/02/27/63fcbdb7c3fe2.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

const int N = 100010;

namespace HEAP{
    struct HP{
        int h[N], ph[N], hp[N], cnt, push_cnt;
        HP(){
            memset(h,0,sizeof h);
            memset(ph,0,sizeof ph);
            memset(hp,0,sizeof hp);
            cnt=push_cnt=0;
        }
        void heap_swap(int a, int b){
            swap(ph[hp[a]],ph[hp[b]]);
            swap(hp[a], hp[b]);
            swap(h[a], h[b]);
        }
        void down(int u){
            int t = u;
            if (u * 2 <= cnt && h[u * 2] < h[t]) t = u * 2;
            if (u * 2 + 1 <= cnt && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
            if (u != t){
                heap_swap(u, t);
                down(t);
            }
        }
        void up(int u){
            while (u / 2 && h[u] < h[u / 2]){
                heap_swap(u, u / 2);
                u >>= 1;
            }
        }
        void build(int n){//O(n)构造整个堆
            cnt=n;
            for (int i = n / 2; i; i -- ) down(i);
        }
        void push(int x){
            cnt ++ ;
            push_cnt ++ ;
            ph[push_cnt] = cnt, hp[cnt] = push_cnt;
            h[cnt] = x;
            up(cnt);
        }
        int top(){
            return h[1];
        }
        void pop(){
            heap_swap(1, cnt);
            cnt -- ;
            down(1);
        }
        void erase_k_push(int k){
            k = ph[k];
            heap_swap(k, cnt);
            cnt -- ;
            up(k);
            down(k);
        }
        void update_k_push(int k,int x){
            k = ph[k];
            h[k] = x;
            up(k);
            down(k);
        }
        int size(){
            return cnt;
        }
    };
}using namespace HEAP;

int main(){
    int n,m; cin>>n>>m;
    HP heap;
    FOR(i,1,n){
        cin>>heap.h[i];
    }
    heap.build(n);
    FOR(i,1,m){
        cout<<heap.top()<<" ";
        heap.pop();
    }
    return 0;
}
```
