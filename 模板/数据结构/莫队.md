## 莫队

### AcWing 2492. HH的项链

#### 题目描述

![image-20220809150625797](https://media.opennet.top/i/2023/01/09/63bb974001117.png)

![image-20220809150634852](https://media.opennet.top/i/2023/01/09/63bb974099123.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
#define endl '\n'
using namespace std;

const int N = 50010, M = 200010, S = 1000010;

int n, m, len;
int w[N], bel[N], ans[M];
struct Query{
    int id, l, r;
    bool operator<(const Query &y)const{
        int i = bel[l], j = bel[y.l];
        if(i != j) return i < j;
        if(i%2) return r<y.r;
        return r>y.r;
    }
}q[M];
int cnt[S];

void add(int x, int& res){
    if (!cnt[x]) res ++ ;
    cnt[x] ++ ;
}

void del(int x, int& res){
    cnt[x] -- ;
    if (!cnt[x]) res -- ;
}

void solve(){
    cin>>n;
    FOR(i,1,n) cin>>w[i];
    cin>>m;
    len = max(1, (int)sqrt((double)n * n / m));
    FOR(i,1,n) bel[i]=i/len;
    FOR(i,0,m-1){
        int l, r; cin>>l>>r;
        q[i] = {i, l, r};
    }
    sort(q, q + m);
    for (int k = 0, i = 0, j = 1, res = 0; k < m; k ++ ){
        int id = q[k].id, l = q[k].l, r = q[k].r;
        while (i < r) add(w[ ++ i], res);
        while (i > r) del(w[i -- ], res);
        while (j < l) del(w[j ++ ], res);
        while (j > l) add(w[ -- j], res);
        ans[id] = res;
    }
    FOR(i,0,m-1) cout<<ans[i]<<endl;
}

signed main(){
    cin.tie(0)->sync_with_stdio(0);
    int T=1; //cin>>T;
    while(T--) solve();
    return 0;
}
```

## 带修改莫队

### AcWing 2521. 数颜色

https://www.acwing.com/problem/content/2523/

#### 题目描述

![image-20230227222821064](https://media.opennet.top/i/2023/02/27/63fcbe068cb36.png)

![image-20230227222826823](https://media.opennet.top/i/2023/02/27/63fcbe0bbd281.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
#define endl '\n'
using namespace std;

const int N = 10010, S = 1000010;

int n, m, mq, mc, len;
int w[N], cnt[S], ans[N], bel[N];

struct Query{
    int id, l, r, t;
}q[N];

struct Modify{
    int p, c;
}c[N];

bool cmp(const Query& a, const Query& b){
    int al = bel[a.l], ar = bel[a.r];
    int bl = bel[b.l], br = bel[b.r];
    if (al != bl) return al < bl;
    if (ar != br) return ar < br;
    return a.t < b.t;
}

void add(int x, int& res){
    if (!cnt[x]) res ++ ;
    cnt[x] ++ ;
}

void del(int x, int& res){
    cnt[x] -- ;
    if (!cnt[x]) res -- ;
}

int main(){
    cin>>n>>m;
    FOR(i,1,n) cin>>w[i];
    FOR(i,0,m-1){
        char op[2];
        int a, b;
        cin>>op>>a>>b;
        if (*op == 'Q') mq ++, q[mq] = {mq, a, b, mc};
        else c[ ++ mc] = {a, b};
    }
    len = cbrt((double)n * max(1 , mc)) + 1;
    FOR(i,1,n) bel[i]=i/len;
    sort(q + 1, q + mq + 1, cmp);
    for (int i = 0, j = 1, t = 0, k = 1, res = 0; k <= mq; k ++ ){
        int id = q[k].id, l = q[k].l, r = q[k].r, tm = q[k].t;
        while (i < r) add(w[ ++ i], res);
        while (i > r) del(w[i -- ], res);
        while (j < l) del(w[j ++ ], res);
        while (j > l) add(w[ -- j], res);
        while (t < tm){
            t ++ ;
            if (c[t].p >= j && c[t].p <= i){
                del(w[c[t].p], res);
                add(c[t].c, res);
            }
            swap(w[c[t].p], c[t].c);
        }
        while (t > tm){
            if (c[t].p >= j && c[t].p <= i){
                del(w[c[t].p], res);
                add(c[t].c, res);
            }
            swap(w[c[t].p], c[t].c);
            t -- ;
        }
        ans[id] = res;
    }
    FOR(i,1,mq) cout<<ans[i]<<endl;
    return 0;
}
```

