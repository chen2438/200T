### 性质

若有 n 个点，最多有 3n-6 条边，2n-4 个面

复杂度：$O(n^2)$

### AcWing 2119. 最佳包裹

#### 题目描述

![image-20220804104622629](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-08-04-024623.png)

![image-20220804104633686](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-08-04-024634.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

const int N = 210;

namespace geo3D{
    const double PI = acos(-1);
    const double eps = 1e-10;
    double rand_eps(){
        return ((double)rand()/RAND_MAX-0.5)*eps;
    }
    struct PT{
        double x,y,z;
        PT() {x=0,y=0,z=0;}
        PT(double a,double b,double c) {x=a,y=b,z=c;}
        friend ostream &operator<<(ostream &o,const PT &X){
            o<<X.x<<' '<<X.y<<' '<<X.z;return o;}
        friend istream &operator>>(istream &i,PT &X){ 
            i>>X.x>>X.y>>X.z;return i;}
        PT operator-() {return PT(-x,-y,-z);}
        PT operator+(const PT &B){
            return {x+B.x,y+B.y,z+B.z};}
        PT operator-(const PT &B){
            return {x-B.x,y-B.y,z-B.z};}
        PT operator*(const double k){return {x*k,y*k,z*k};}
        friend PT operator*(const double k,PT T){return T*k;}
        PT operator/(const double k){return {x/k,y/k,z/k};}
        double operator&(const PT &t){//点乘
            return x*t.x+y*t.y+z*t.z;}
        PT operator*(const PT &t){//叉乘
        return {y*t.z-t.y*z,z*t.x-x*t.z,x*t.y-y*t.x};}
        bool operator==(const PT &Y){
            return (x==Y.x)&&(y==Y.y)&&(z==Y.z);}
        bool operator!=(const PT &Y){
            return (x!=Y.x)||(y!=Y.y)||(z!=Y.z);}
        double size(){return sqrt(x*x+y*y+z*z);}
        void shake(){
            x+=rand_eps(),y+=rand_eps(),z+=rand_eps();}
    };
    
    struct LI{
        PT st,ed;
    };
    
    struct PL{
        PT v[3];//逆时针存3个点
        PT norm(){//法向量
            return (v[1]-v[0])*(v[2]-v[0]);
        }
        double area(){return norm().size()/2;}
        bool above(PT a){//点a是否在上方
            return ((a-v[0])&norm())>=0;}
    };
    
    struct IPL{
        int v[3];
    };
}
 
using namespace geo3D;

namespace CV3D{
    bool g[N][N];
    vector<PT> q;//点
    vector<PL> plane,np;//面,面的备份
    vector<IPL> ip,nip;//面的三个点的坐标
    void get_convex_3d(){
        memset(g,0,sizeof(g));
        plane.push_back({q[0], q[1], q[2]});
        plane.push_back({q[2], q[1], q[0]});
        ip.push_back({0, 1, 2});
        ip.push_back({2, 1, 0});
        int lenq=q.size();
        FOR(i,3,lenq-1){
            int lenp=plane.size();
            FOR(j,0,lenp-1){
                bool t = plane[j].above(q[i]);
                if (!t){
                    np.push_back(plane[j]);
                    nip.push_back(ip[j]);
                }
                FOR(k,0,2)
                    g[ip[j].v[k]][ip[j].v[(k+1)%3]]=t;
            }
            FOR(j,0,lenp-1)
                FOR(k,0,2){
                    int a = ip[j].v[k], b = ip[j].v[(k + 1) % 3];
                    if (g[a][b] && !g[b][a]){
                        np.push_back({q[a],q[b],q[i]});
                        nip.push_back({a, b, i});
                    }
                }
            plane.swap(np);
            np.clear();
            ip.swap(nip);
            nip.clear();
        }
    }
}using namespace CV3D;

int main(){
    cin.tie(0)->sync_with_stdio(0);
    int n; cin>>n;
    FOR(i,0,n-1){
        PT x; cin>>x;
        x.shake();
        q.push_back(x);
    }
    get_convex_3d();
    double res = 0;
    for(auto i:plane) res += i.area();
    printf("%lf\n", res);
    return 0;
}
```

