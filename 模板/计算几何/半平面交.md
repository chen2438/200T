复杂度 $O(n\log n)$

![image-20220730101106259](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202207301011356.png)

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

namespace geometry{
    #define PI acos(-1)
    #define eps (1e-8)
    struct PT {
        double x,y;
        PT() {x=0,y=0;}
        PT(double _x,double _y) {x=_x,y=_y;}
        friend ostream &operator<<(ostream &o,\
            const PT &X){
            o<<X.x<<' '<<X.y;
            return o;}
        friend istream &operator>>(istream &i,PT &X){ 
            i>>X.x>>X.y;
            return i;}
        PT operator-() {return PT(-x,-y);}
        PT& operator++() {x=x+1,y=y+1; return *this;}
        PT operator++(int) {
            PT T=*this; ++*this; return T;}
        PT& operator--() {x=x-1,y=y-1; return *this;}
        PT operator--(int) {
            PT T=*this; --*this; return T;}
        PT operator+(const PT &Y){
            PT T;
            T.x=this->x+Y.x;
            T.y=this->y+Y.y;
            return T;}
        PT operator-(const PT &Y){
            PT T;
            T.x=this->x-Y.x;
            T.y=this->y-Y.y;
            return T;}
        PT operator*(const double k){
            return PT(x*k,y*k);}
        PT operator*(const int k){
            return PT(x*k,y*k);}
        friend PT operator*(const double k, PT T){
            return T*k;}
        friend PT operator*(const int k, PT T){
            return T*k;}
        bool operator==(const PT &Y){
            return fabs(x-Y.x)<eps&&fabs(y-Y.y)<eps;}
        bool operator!=(const PT &Y){
        return !(fabs(x-Y.x)<eps&&fabs(y-Y.y)<eps);}
        double size(){return sqrt(x*x+y*y);}
        PT rotate(double angle){
            //返回顺时针旋转angle弧度,不改变自身
            double nx=x*cos(angle)+y*sin(angle);
            double ny=-x*sin(angle)+y*cos(angle);
            return {nx,ny};}
    };

    struct LI{
        PT st, ed;//起点，终点
        double get_angle(){
            return atan2(ed.y - st.y, ed.x - st.x);}
    };
    int sign(double x){  // 符号函数
        if (fabs(x) < eps) return 0;
        if (x < 0) return -1;
        return 1;
    }
    bool aless( LI& a,  LI& b){
        double A = a.get_angle(), B = b.get_angle();
        if (!sign(A- B)) return area(a.st, a.ed, b.ed) < 0;
        return A < B;
    }
    bool xless(const PT &A,const PT &B){
        if(sign(A.x-B.x)==0) return A.y<B.y;
        return A.x<B.x;
    }
    double dot(PT a, PT b) {return a.x*b.x+a.y*b.y;}
    //点乘
    double cross(PT a,PT b){return a.x*b.y-b.x*a.y;}
    //叉乘,A与B张成的平行四边形的有向面积
    //B在A的逆时针方向为正
    double angle(PT a,PT b){//夹角
        return acos(dot(a,b)/a.size()/b.size());
    }
    double ang(double rad) {return rad/PI*180;}
    double rad(double ang) {return ang/180*PI;}
    double area(double a,double b,double c){
        //传入三角形三条边,返回面积
        double p=(a+b+c)/2;
        return sqrt(p*(p-a)*(p-b)*(p-c));
    }
    double area(PT o,PT a,PT b){
        //传入三角形三个点,返回有向面积
        //OB在OA的逆时针方向(左边)为正
        return cross(o-a,o-b)/2;
    }
    double area(PT A,PT B){
        //传入三角形2个向量,返回有向面积
        //B在A的逆时针方向(左边)为正
        return cross(A,B)/2;
    }
    PT line_x_line(PT p,PT v,PT q,PT w){
        //以p为起点,q为方向向量的直线l1与l2的交点
        PT u = p - q;
        double t = cross(w, u) / cross(v, w);
        return p + v * t;
    }
    double dist2line(PT p,PT l,PT r){
        //点p到直线(l->r)的距离
        PT v1 = r - l, v2 = p - l;
        return fabs(cross(v1, v2) / v1.size());
    }
    double dist2sgt(PT p,PT l,PT r){
        //点p到线段(l->r)的距离
        if (l == r) return (p-l).size();
        PT v1 = r - l, v2 = p - l, v3 = p - r;
        if(sign(dot(v1, v2))<0) return v2.size();
        if(sign(dot(v1, v3))>0) return v3.size();
        return dist2line(p,l,r);
    }
    PT line_proj(PT p,PT l,PT r){
        //点p在直线(l->r)的投影
        PT v = r - l;
        return l+v*(dot(v,p-l)/dot(v,v));
    }
    bool on_sgt(PT p,PT l,PT r){
        //点p是否在线段(l,r)上
        return sign(cross(p-l,p-r))==0&&\
            sign(dot(p-l,p-r))<=0;
    }
    bool sgt_x_sgt(PT l1,PT r1,PT l2,PT r2){
        //判断线段(l1->r1)与线段(l2->r2)是否相交
        double c1,c2,c3,c4;
        c1=cross(r1-l1,l2-l1),c2=cross(r1-l1,r2-l1);
        c3=cross(r2-l2,r1-l2),c4=cross(r2-l2,l1-l2);
        return sign(c1)*sign(c2)<=0&&\
            sign(c3)*sign(c4)<=0;
    }
    bool sgt_x_line(PT a,PT b,PT l,PT r){
        //判断线段(a->b)与直线(l->rr)是否相交
        return sign(area(a,l,r))*sign(area(b,l,r)) <= 0;
    }
    double polygon_area(PT p[], int n){
        //求多边形面积（不一定是凸多边形）
        //p[]通常按逆时针存储所有点,n是边数
        double s = 0;
        for(int i = 1; i + 1 < n; i ++ )
            s+=cross(p[i]-p[0],p[i+1]-p[i]);
        return s / 2;
    }
}

using namespace geometry;

const int N = 510;
// const double eps = 1e-8;

vector<LI>line;

PT pg[N], ans[N];
int q[N];

PT get_line_intersection(PT p, PT v, PT q, PT w)
{
    auto u = p - q;
    double t = cross(w, u) / cross(v, w);
    return {p.x + v.x * t, p.y + v.y * t};
}

PT get_line_intersection(LI a, LI b)
{
    return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st);
}

// bc的交点是否在a的右侧
bool on_right(LI& a, LI& b, LI& c)
{
    auto o = get_line_intersection(b, c);
    return sign(area(a.st, a.ed, o)) <= 0;
}

double half_plane_intersection()
{
    sort(line.begin(),line.end(), aless);
    int hh = 0, tt = -1;
    for (int i = 0; i < line.size(); i ++ )
    {
        if (i && !sign(get_angle(line[i]) - get_angle(line[i - 1]))) continue;
        while (hh + 1 <= tt && on_right(line[i], line[q[tt - 1]], line[q[tt]])) tt -- ;
        while (hh + 1 <= tt && on_right(line[i], line[q[hh]], line[q[hh + 1]])) hh ++ ;
        q[ ++ tt] = i;
    }
    while (hh + 1 <= tt && on_right(line[q[hh]], line[q[tt - 1]], line[q[tt]])) tt -- ;
    while (hh + 1 <= tt && on_right(line[q[tt]], line[q[hh]], line[q[hh + 1]])) hh ++ ;

    q[ ++ tt] = q[hh];
    int k = 0;
    for (int i = hh; i < tt; i ++ )
        ans[k ++ ] = get_line_intersection(line[q[i]], line[q[i + 1]]);
    double res = 0;
    for (int i = 1; i + 1 < k; i ++ )
        res += area(ans[0], ans[i], ans[i + 1]);
    return res ;
}

int main()
{
    int n, m;
    scanf("%d", &n);
    while (n -- )
    {
        scanf("%d", &m);
        for (int i = 0; i < m; i ++ ) scanf("%lf%lf", &pg[i].x, &pg[i].y);
        for (int i = 0; i < m; i ++ )
            line.push_back({pg[i], pg[(i + 1) % m]});
    }
    double res = half_plane_intersection();
    printf("%.3lf\n", res);

    return 0;
}

```

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>

#define x first
#define y second

using namespace std;

typedef pair<double,double> PDD;
const int N = 510;
const double eps = 1e-8;

struct Line
{
    PDD st, ed;
};
vector<Line>line;
PDD pg[N], ans[N];
int q[N];

int sign(double x)
{
    if (fabs(x) < eps) return 0;
    if (x < 0) return -1;
    return 1;
}

int dcmp(double x, double y)
{
    if (fabs(x - y) < eps) return 0;
    if (x < y) return -1;
    return 1;
}

double get_angle(const Line& a)
{
    return atan2(a.ed.y - a.st.y, a.ed.x - a.st.x);
}

PDD operator-(PDD a, PDD b)
{
    return {a.x - b.x, a.y - b.y};
}

double cross(PDD a, PDD b)
{
    return a.x * b.y - a.y * b.x;
}

double area(PDD a, PDD b, PDD c)
{
    return cross(b - a, c - a);
}

bool cmp(const Line& a, const Line& b)
{
    double A = get_angle(a), B = get_angle(b);
    if (!dcmp(A, B)) return area(a.st, a.ed, b.ed) < 0;
    return A < B;
}

PDD get_line_intersection(PDD p, PDD v, PDD q, PDD w)
{
    auto u = p - q;
    double t = cross(w, u) / cross(v, w);
    return {p.x + v.x * t, p.y + v.y * t};
}

PDD get_line_intersection(Line a, Line b)
{
    return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st);
}

// bc的交点是否在a的右侧
bool on_right(Line& a, Line& b, Line& c)
{
    auto o = get_line_intersection(b, c);
    return sign(area(a.st, a.ed, o)) <= 0;
}

double half_plane_intersection()
{
    sort(line.begin(),line.end(), cmp);
    int hh = 0, tt = -1;
    for (int i = 0; i < line.size(); i ++ )
    {
        if (i && !dcmp(get_angle(line[i]), get_angle(line[i - 1]))) continue;
        while (hh + 1 <= tt && on_right(line[i], line[q[tt - 1]], line[q[tt]])) tt -- ;
        while (hh + 1 <= tt && on_right(line[i], line[q[hh]], line[q[hh + 1]])) hh ++ ;
        q[ ++ tt] = i;
    }
    while (hh + 1 <= tt && on_right(line[q[hh]], line[q[tt - 1]], line[q[tt]])) tt -- ;
    while (hh + 1 <= tt && on_right(line[q[tt]], line[q[hh]], line[q[hh + 1]])) hh ++ ;

    q[ ++ tt] = q[hh];
    int k = 0;
    for (int i = hh; i < tt; i ++ )
        ans[k ++ ] = get_line_intersection(line[q[i]], line[q[i + 1]]);
    double res = 0;
    for (int i = 1; i + 1 < k; i ++ )
        res += area(ans[0], ans[i], ans[i + 1]);
    return res / 2;
}

int main()
{
    int n, m;
    scanf("%d", &n);
    while (n -- )
    {
        scanf("%d", &m);
        for (int i = 0; i < m; i ++ ) scanf("%lf%lf", &pg[i].x, &pg[i].y);
        for (int i = 0; i < m; i ++ )
            line.push_back({pg[i], pg[(i + 1) % m]});
    }
    double res = half_plane_intersection();
    printf("%.3lf\n", res);

    return 0;
}

```

