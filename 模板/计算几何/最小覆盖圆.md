### 性质

1. 最小覆盖圆唯一
2. 若点 $P \notin S$ 不在 点集 $S$ 的最小覆盖圆内部，则 $P$ 在 $\{P\}\cup S$ 的最小覆盖圆的圆周上

复杂度：期望 $O(n)$

### AcWing 3028. 最小圆覆盖

#### 题目描述

![image-20220803131341281](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208031313341.png)

![image-20220803131347657](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208031313683.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

namespace geometry{
 略
}
 
using namespace geometry;

namespace MICC{//minimum covering circle
    vector<PT> q;
    CI micc(){
        int n=q.size();
        random_shuffle(q.begin(),q.end());
        CI c={q[0],0};
        FOR(i,1,n-1){
            if(sign(c.r-len(c.p, q[i])) < 0){
                c={q[i],0};
                FOR(j,0,i-1){
                    if(sign(c.r-len(c.p,q[j])) < 0){
                        c={(q[i]+q[j])/2, len(q[i],q[j])/2};
                        FOR(k,0,j-1){
                            if(sign(c.r-len(c.p,q[k])) < 0)
                                c=get_circle(q[i],q[j],q[k]);
                        }
                    }
                }
            }
        }
        return c;
    }
}using namespace MICC; 

int main(){
    int n; cin>>n;
    FOR(i,0,n-1){
        PT x; cin>>x;
        q.push_back(x);
    }
    CI c=micc();
    printf("%.10lf\n", c.r);
    printf("%.10lf %.10lf\n", c.p.x, c.p.y);
    return 0;
}
```

### AcWing 2785. 信号增幅仪

#### 题目描述

![image-20220803135829862](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208031358914.png)

![image-20220803135838730](https://nme-200t.oss-cn-hangzhou.aliyuncs.com/template/202208031358761.png)

#### 代码

将椭圆及其坐标系做仿射变换，然后做最小圆覆盖

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

namespace geometry{
 略
}using namespace geometry;

namespace MICC{//minimum covering circle
    vector<PT> q;
    CI micc(){
        int n=q.size();
        random_shuffle(q.begin(),q.end());
        CI c={q[0],0};
        FOR(i,1,n-1){
            if(sign(c.r-len(c.p, q[i])) < 0){
                c={q[i],0};
                FOR(j,0,i-1){
                    if(sign(c.r-len(c.p,q[j])) < 0){
                        c={(q[i]+q[j])/2, len(q[i],q[j])/2};
                        FOR(k,0,j-1){
                            if(sign(c.r-len(c.p,q[k])) < 0)
                                c=get_circle(q[i],q[j],q[k]);
                        }
                    }
                }
            }
        }
        return c;
    }
}using namespace MICC; 

int main(){
    int n; cin>>n;
    FOR(i,0,n-1){
        PT x; cin>>x;
        q.push_back(x);
    }
    double a,p; cin>>a>>p;
    FOR(i,0,n-1){
        q[i]=q[i].rotate(rad(a));
        q[i].x/=p;
    }
    CI c=micc();
    printf("%.3lf\n", c.r);
    return 0;
}
```

