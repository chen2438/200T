### AcWing 3074. 自适应辛普森积分

https://www.acwing.com/problem/content/3077/

#### 题目描述

![image-20230227222407285](https://media.opennet.top/i/2023/02/27/63fcbd0882daf.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

namespace SMPS{
    const double eps = 1e-12;
    double f(double x){
        return sin(x) / x;
    }
    double simpson(double l, double r){
        auto mid = (l + r) / 2;
        return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;
    }
    double asr(double l, double r, double s){
        auto mid = (l + r) / 2;
        auto left = simpson(l, mid), right = simpson(mid, r);
        if (fabs(left + right - s) < eps) return left + right;
        return asr(l, mid, left) + asr(mid, r, right);
    }
}using namespace SMPS;

int main(){
    double l, r; cin>>l>>r;
    printf("%lf\n", asr(l, r, simpson(l, r)));
    return 0;
}
```

### AcWing 3069. 圆的面积并

https://www.acwing.com/problem/content/3072/

#### 题目描述

![image-20230227222425700](https://media.opennet.top/i/2023/02/27/63fcbd1ad0c62.png)

#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

#define x first
#define y second

typedef pair<double, double> PDD;
const int N = 1010;
const double eps = 1e-8;

int n;
struct Circle{
    PDD r;
    double R;
}c[N];
PDD q[N];

int dcmp(double x, double y){
    if (fabs(x - y) < eps) return 0;
    if (x < y) return -1;
    return 1;
}

namespace SMPS{
    double f(double x){
        int cnt = 0;
        for (int i = 0; i < n; i ++ ){
            auto X = fabs(x - c[i].r.x), R = c[i].R;
            if (dcmp(X, R) < 0){
                auto Y = sqrt(R * R - X * X);
                q[cnt ++ ] = {c[i].r.y - Y, c[i].r.y + Y};
            }
        }
        if (!cnt) return 0;
        sort(q, q + cnt);
        double res = 0, st = q[0].x, ed = q[0].y;
        for (int i = 1; i < cnt; i ++ )
            if (q[i].x <= ed) ed = max(ed, q[i].y);
            else{
                res += ed - st;
                st = q[i].x, ed = q[i].y;
            }
        return res + ed - st;
    }
    double simpson(double l, double r){
        auto mid = (l + r) / 2;
        return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;
    }
    double asr(double l, double r, double s){
        auto mid = (l + r) / 2;
        auto left = simpson(l, mid), right = simpson(mid, r);
        if (fabs(s - left - right) < eps) return left + right;
        return asr(l, mid, left) + asr(mid, r, right);
    }
}using namespace SMPS;

int main(){
    scanf("%d", &n);
    double l = 2000, r = -2000;
    for (int i = 0; i < n; i ++ ){
        scanf("%lf%lf%lf", &c[i].r.x, &c[i].r.y, &c[i].R);
        l = min(l, c[i].r.x - c[i].R), r = max(r, c[i].r.x + c[i].R);
    }
    printf("%.3lf\n", asr(l - 100, r + 100, simpson(l, r)));
    return 0;
}
```

