### AcWing 905. 区间选点

![image-20220722214203283](https://media.opennet.top/i/2023/01/09/63bb975d71652.png)

![image-20220722214208441](https://media.opennet.top/i/2023/01/09/63bb975de5b86.png)

#### 思路

区间按右端点排序并遍历，如果区间内没有点则在区间的右端点选点。

![image-20220722215008863](https://media.opennet.top/i/2023/01/09/63bb975eccb3d.png)

#### 代码

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;

const int N = 100010;

int n;
struct Range{
    int l, r;
    bool operator< (const Range &W)const{
        return r < W.r;
    }
}range[N];

int main(){
    cin.tie(0)->sync_with_stdio(0);
    cin>>n;
    FOR(i,0,n) cin>>range[i].l>>range[i].r;
    sort(range, range + n);
    int res = 0, ed = -2e9;
    FOR(i,0,n)
        if (range[i].l > ed){
            res ++ ;
            ed = range[i].r;
        }
    cout<<res<<endl;
    return 0;
}
```

### AcWing 908. 最大不相交区间数量

![image-20220722215617854](https://media.opennet.top/i/2023/01/09/63bb975fa3edb.png)

![image-20220722215623237](https://media.opennet.top/i/2023/01/09/63bb9760496b4.png)

#### 思路

同 AcWing 905. 区间选点。

#### 代码

同 AcWing 905. 区间选点。

### AcWing 907. 区间覆盖

#### 题目描述

![image-20220802123029279](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-08-02-043029.png)

![image-20220802123038650](http://nme-200t.oss-cn-hangzhou.aliyuncs.com/notes/2022-08-02-043039.png)

#### 最小区间覆盖模板

```cpp
namespace RGCV{//range cover
    struct RG{
        int l, r, idx;
        bool operator< (const RG &W)const{
            return l < W.l;
        }
        friend ostream &operator<<(ostream &o,const RG &X){
            o<<X.l<<' '<<X.r;return o;}
        friend istream &operator>>(istream &i,RG &X){ 
            i>>X.l>>X.r;return i;}
        bool operator==(const RG &Y){
            return (l==Y.l)&&(r==Y.r);}
        bool operator!=(const RG &Y){
            return (l!=Y.l)||(r!=Y.r);}
    };
    vector<RG> rg,res;
    vector<RG> cover(int st, int ed){//覆盖[st,ed]
        st--;//允许2个区间端点差1,而不是端点重合
        //如果需要端点重合,不需要st--
        res.clear();
        int len = rg.size();
        sort(rg.begin(),rg.end());
        int success = 0;
        FOR(i,0,len-1){
            int j = i, r = -2e9;
            RG t=rg[j];
            while (j < len && rg[j].l <= st+1){
                //允许2个区间端点差1,而不是端点重合
                //如果需要端点重合,不需要 st+1
                if(r<rg[j].r){
                    r=rg[j].r;
                    t=rg[j];
                }
                j ++ ;
            }
            if (r < st) {success = 0; break;}
            res.push_back(t);
            if (r >= ed){success = 1; break;}
            st = r;
            i = j - 1;
        }
        if (!success) res.clear();
        return res;
    }
}using namespace RGCV;
```



#### 代码

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;

const int N = 100010;

namespace RGCV{//range cover
    struct RG{
        int l, r, idx;
        bool operator< (const RG &W)const{
            return l < W.l;
        }
        friend ostream &operator<<(ostream &o,const RG &X){
            o<<X.l<<' '<<X.r;return o;}
        friend istream &operator>>(istream &i,RG &X){ 
            i>>X.l>>X.r;return i;}
        bool operator==(const RG &Y){
            return (l==Y.l)&&(r==Y.r);}
        bool operator!=(const RG &Y){
            return (l!=Y.l)||(r!=Y.r);}
    };
    vector<RG> rg,res;
    vector<RG> cover(int st, int ed){//覆盖[st,ed]
        // st--;//允许2个区间端点差1,而不是端点重合
        //如果需要端点重合,不需要st--
        res.clear();
        int len = rg.size();
        sort(rg.begin(),rg.end());
        int success = 0;
        FOR(i,0,len-1){
            int j = i, r = -2e9;
            RG t=rg[j];
            while (j < len && rg[j].l <= st){
                //允许2个区间端点差1,而不是端点重合
                //如果需要端点重合,不需要 st+1
                if(r<rg[j].r){
                    r=rg[j].r;
                    t=rg[j];
                }
                j ++ ;
            }
            if (r < st) {success = 0; break;}
            res.push_back(t);
            if (r >= ed){success = 1; break;}
            st = r;
            i = j - 1;
        }
        if (!success) res.clear();
        return res;
    }
}using namespace RGCV;

int n;

int main(){
    int st, ed; cin>>st>>ed>>n;
    FOR(i,0,n-1){
        int l, r; cin>>l>>r;
        RGCV::rg.push_back({l,r});
    }
    int ans=RGCV::cover(st,ed).size();
    if(ans==0) cout<<"-1\n";
    else cout<<ans<<endl;
    return 0;
}
```

